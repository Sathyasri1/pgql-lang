module GraphPattern

imports
  
  Literals
  Names
  Expressions
  Legacy

template options

  keyword -/- [a-zA-Z0-9]

context-free syntax

  GraphPattern.GraphPattern = PathPatternList KeepClause? WhereClause?
  PathPatternList.PathPatternList = <<{PathPattern ","}+>>

  PathPattern.PathPattern = Vertex EdgeVertex+
  PathPattern.SingleVertex = <(<ElemContents>)> // PGQL 1.0
  Vertex.Vertex = <(<ElemContents>)>

  EdgeVertex.EdgeVertex = Connection Vertex
  Connection.OutConn = [-[EdgeOrPathContents?]->[PathQuantifier?]]
  Connection.InConn = [<-[EdgeOrPathContents?]-[PathQuantifier?]]
  Connection.UndirectedEdge = [-[EdgeContents?]-[PathQuantifier?]]
  Connection.OutEdge = [->[PathQuantifier?]]
  Connection.InEdge = [<-[PathQuantifier?]]
  Connection.UndirectedEdge = [-[PathQuantifier?]]

  RelaxedPathPattern.RelaxedPathPattern = <<Vertex?> <RelaxedEdgeVertex+>> // relaxed means that the vertices can be omitted
  RelaxedEdgeVertex.RelaxedEdgeVertex = <<Connection> <Vertex?>>

  Connection.ParenthesizedPath = <( <RelaxedPathPattern> <WhereClause?> <CostClause?> )<PathQuantifier?>>

  PathPattern.AnyPath = <ANY <OptionallyParenthesizedPathPattern>> {case-insensitive, avoid}
  PathPattern.AllPaths = <ALL <OptionallyParenthesizedPathPattern>> {case-insensitive, avoid}
  PathPattern.Shortest = <<TopKAnyAll?> SHORTEST <OptionallyParenthesizedPathPattern>> {case-insensitive, prefer}
  PathPattern.Cheapest = <<TopKAnyAll?> CHEAPEST <OptionallyParenthesizedPathPattern>> {case-insensitive, prefer}
  OptionallyParenthesizedPathPattern = <( <PathPattern> )>
  OptionallyParenthesizedPathPattern = PathPattern

  TopKAnyAll.TopK = <TOP <UNSIGNED-INT>> {case-insensitive}
  TopKAnyAll.Any = <Any> {case-insensitive}
  TopKAnyAll.All = <ALL> {case-insensitive}

  CostClause.CostClause = <COST <Exp>> {case-insensitive}

  EdgeContents.EdgeContents = <[<ElemContents>]>
  EdgeOrPathContents = EdgeContents
  EdgeOrPathContents.Path = </<Identifier?><LabelExpression><PathQuantifier?>/>

  PathQuantifier.ZeroOrMore = <*>
  PathQuantifier.OneOrMore = <+>
  PathQuantifier.Optional = <?>
  PathQuantifier.ExactlyN = <{<UNSIGNED-INT>}>
  PathQuantifier.NOrMore = <{<UNSIGNED-INT>,}>
  PathQuantifier.BetweenNAndM = <{<UNSIGNED-INT>,<UNSIGNED-INT>}>
  PathQuantifier.BetweenZeroAndM = <{,<UNSIGNED-INT>}>

context-free syntax

  ElemContents.ElemContents       = <<Identifier?><LabelExpression?><Legacy10Ids?><Legacy10WithInlinedConstraints?>>
  LabelExpression.Labels          = <<LabelExpressionIntroducer> <Labels>>
  LabelExpressionIntroducer.Colon = <:>
  LabelExpressionIntroducer.IS    = <IS> {case-insensitive}
  Labels.Label                    = Identifier
  Labels                          = BindVariable
  Labels.LabelDisjunction         = <<Labels>|<Labels>> {left}

context-free syntax

  KeepClause.KeepClause = <KEEP <PathPatternPrefix>> {case-insensitive}
  PathPatternPrefix = PathSearchPrefix

  PathSearchPrefix = AllPathSearch
  PathSearchPrefix = AnyPathSearch
  PathSearchPrefix = ShortestPathSearch
  PathSearchPrefix = CheapestPathSearch

  AllPathSearch.AllPathSearch = <ALL <PathOrPaths>> {case-insensitive}

  AnyPathSearch.AnyPathSearch = <ANY <NumberOfPaths?> <PathOrPaths>> {case-insensitive}

  ShortestPathSearch.AllShortestPathSearch = <ALL SHORTEST <PathOrPaths>> {case-insensitive}
  ShortestPathSearch.AnyShortestPathSearch = <ANY SHORTEST <PathOrPaths>> {case-insensitive}
  ShortestPathSearch.CountedShortestPathSearch = <SHORTEST <NumberOfPaths> <PathOrPaths>> {case-insensitive}

  CheapestPathSearch.AnyCheapestPathSearch = <ANY CHEAPEST <PathOrPaths>> {case-insensitive}
  CheapestPathSearch.CountedCheapestPathSearch = <CHEAPEST <NumberOfPaths> <PathOrPaths>> {case-insensitive}

  NumberOfPaths.NumberOfPaths = UNSIGNED-INT

  PathOrPaths.PathKeyword = <PATH> {case-insensitive}
  PathOrPaths.PathsKeyword = <PATHS> {case-insensitive}
